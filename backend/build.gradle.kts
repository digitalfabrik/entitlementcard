import org.jetbrains.kotlin.gradle.dsl.JvmTarget

/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Kotlin application project to get you started.
 */
val isProductionEnvironment = System.getProperty("env") == "prod"

plugins {
    alias(libs.plugins.com.google.protobuf)
    alias(libs.plugins.com.expediagroup.graphql)
    alias(libs.plugins.io.gitlab.arturbosch.detekt)
    alias(libs.plugins.org.jetbrains.kotlin.jvm)
    alias(libs.plugins.org.jetbrains.kotlinx.kover)
    alias(libs.plugins.org.jlleitschuh.gradle.ktlint)
    alias(libs.plugins.io.sentry.jvm.gradle)
    // Apply the application plugin to add support for building a CLI application.
    application
}

repositories {
    mavenCentral()
}

dependencies {
    implementation(libs.at.favre.lib.bcrypt)
    implementation(libs.com.auth0.java.jwt) // JSON web tokens
    implementation(libs.com.eatthepath.java.otp) // dynamic card verification
    implementation(libs.com.expediagroup.graphql.kotlin.schema.generator)
    testImplementation(libs.com.expediagroup.graphql.kotlin.client)
    implementation(libs.com.fasterxml.jackson.dataformat.xml)
    implementation(libs.com.fasterxml.jackson.dataformat.yaml)
    implementation(libs.com.fasterxml.jackson.datatype.jsr310)
    implementation(libs.com.fasterxml.jackson.module.kotlin)
    implementation(libs.com.google.zxing.core) // QR-Codes
    implementation(libs.com.github.ajalt.clikt)
    implementation(libs.com.google.protobuf.kotlin)
    implementation(libs.com.graphql.java.extended.scalars)
    implementation(libs.de.grundig.geojson.jackson)
    implementation(libs.io.javalin)
    testImplementation(libs.io.javalin.testtools)
    implementation(libs.io.ktor.client.core.jvm)
    implementation(libs.io.ktor.client.cio.jvm)
    testImplementation(libs.io.mockk)
    implementation(libs.net.postgis.jdbc)
    implementation(libs.org.apache.commons.text)
    implementation(libs.org.apache.commons.csv)
    implementation(libs.org.bouncycastle.bcpkix.jdk18on)
    implementation(libs.org.jetbrains.exposed.core)
    implementation(libs.org.jetbrains.exposed.dao)
    implementation(libs.org.jetbrains.exposed.jdbc)
    implementation(libs.org.jetbrains.exposed.java.time)
    testImplementation(libs.org.jetbrains.kotlin.test)
    implementation(libs.org.jetbrains.kotlin.stdlib)
    implementation(libs.org.jetbrains.kotlinx.html.jvm)
    implementation(libs.org.jetbrains.kotlinx.serialization.json)
    testImplementation(libs.org.junit.jupiter)
    testImplementation(libs.org.junit.jupiter.params)
    implementation(libs.org.piwik.java.tracking.matomo.java.tracker)
    implementation(libs.org.postgresql.postgresql)
    implementation(libs.com.kohlschutter.junixsocket.common) // required for PostgreSQL Unix domain socket support
    implementation(libs.com.kohlschutter.junixsocket.core)
    implementation(libs.org.slf4j.simple)
    implementation(libs.org.simplejavamail)
    testImplementation(libs.org.testcontainers)
    testImplementation(libs.org.testcontainers.postgresql)
}

kotlin {
    compilerOptions {
        jvmTarget.set(JvmTarget.JVM_17)
    }
}

detekt {
    // https://detekt.dev/docs/gettingstarted/gradle
    toolVersion = "1.23.8"
    config.setFrom(file("../detekt.yml"))
    buildUponDefaultConfig = true
    basePath = project.layout.projectDirectory.toString()
    ignoreFailures = true
}

ktlint {
    version.set("1.5.0")
    filter {
        exclude { it.file.path.contains("${layout.buildDirectory.get()}/generated/") }
    }
}

if (isProductionEnvironment) {
    sentry {
        // Generates a JVM (Java, Kotlin, etc.) source bundle and uploads your source code to Sentry.
        // This enables source context, allowing you to see your source
        // code as part of your stack traces in Sentry.
        includeSourceContext = true

        org = "digitalfabrik"
        projectName = "entitlementcard-backend"
        authToken = System.getenv("SENTRY_AUTH_TOKEN")
    }
}

sourceSets {
    main {
        proto {
            srcDir("../specs")
        }
    }
    test {
        kotlin {
            srcDir("${layout.buildDirectory.get()}/generated/source/graphql")
        }
    }
}

java {
    targetCompatibility = JavaVersion.VERSION_17
}

protobuf {
    generateProtoTasks {
        all().configureEach {
            builtins {
                create("kotlin")
            }
        }
    }
}

application {
    // Define the main class for the application.
    mainClass.set("app.ehrenamtskarte.backend.EntryPointKt")
}

kover {
    reports {
        filters {
            includes {
                classes("app.ehrenamtskarte.backend.*")
            }
        }
    }
}

tasks.withType<JavaExec>().configureEach {
    systemProperties = properties
    environment("JWT_SECRET", "HelloWorld")
    environment("KOBLENZ_PEPPER", "123456789ABC")
}

tasks.register<Copy>("copyStyle") {
    from("$rootDir/ehrenamtskarte-maplibre-style/style.json")
    into("${layout.buildDirectory.get()}/resources/main/styles")
}

tasks.named("classes") {
    dependsOn(tasks.named("copyStyle"))
}

tasks.test {
    dependsOn("graphqlGenerateTestClient")
    useJUnitPlatform()
    environment("JWT_SECRET", "HelloWorld")
    environment("KOBLENZ_PEPPER", "123456789ABC")
}

tasks.sentryCollectSourcesJava {
    dependsOn(tasks.generateProto)
}

tasks.generateProto {
    dependsOn(tasks.generateSentryBundleIdJava)
}

tasks.graphqlGenerateTestClient {
    dependsOn(tasks.generateSentryBundleIdJava)
    dependsOn(tasks.sentryCollectSourcesJava)
    schemaFile.set(rootDir.parentFile.resolve("specs/backend-api.graphql"))
    packageName.set("app.ehrenamtskarte.backend.generated")
    queryFiles.setFrom(fileTree("src/test/resources/graphql"))
}

tasks.register<JavaExec>("db-clear") {
    group = "application"
    mainClass = application.mainClass.get()
    classpath = sourceSets.main.get().runtimeClasspath
    args("db-clear")
}

tasks.register<JavaExec>("db-migrate") {
    group = "application"
    mainClass = application.mainClass.get()
    classpath = sourceSets.main.get().runtimeClasspath
    args("migrate")
}

tasks.register<JavaExec>("db-import-online") {
    group = "application"
    mainClass = application.mainClass.get()
    classpath = sourceSets.main.get().runtimeClasspath
    args("import")
}

tasks.register<JavaExec>("db-import-dev") {
    group = "application"
    mainClass = application.mainClass.get()
    classpath = sourceSets.main.get().runtimeClasspath
    args("db-import-dev", "src/dev/sql")
}

tasks.register("db-recreate") {
    group = "application"
    val dbClear = tasks.getByName("db-clear")
    val dbMigrate = tasks.getByName("db-migrate")
    val dbImportOnline = tasks.getByName("db-import-online")
    val dbImportDev = tasks.getByName("db-import-dev")
    dbMigrate.dependsOn(dbClear)
    dbImportOnline.dependsOn(dbMigrate)
    dbImportDev.dependsOn(dbImportOnline)
    this.dependsOn(dbImportDev)
}
